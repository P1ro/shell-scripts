$ echo $PS1
[PEXP\[\]ECT_PROMPT>

# Delete all aliases and function
# TODO: Instead start from pristine environment
$ unalias -a
$ alias | wc -l
$ for f in $(typeset -f | egrep '^\w+'); do unset -f $f; done
$ typeset -f | egrep '^\w+' | wc -l
# Setting a temp directory for tests
$ TMP=/tmp/test-extensionless
$ BIN_DIR=$PWD/..
0
0

$ alias | wc -l
0

$ temp_dir=$TMP/test-3573
$ mkdir -p "$temp_dir"
$ cd "$temp_dir"
$ pwd
#ALIAS FOR PRINTING SEPERATION LINES (FOR JUPYTER)
$ alias linebr="printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -"
/tmp/test-extensionless/test-3573

# Count aliases proper
$ alias | wc -l
# Count functions
$ typeset -f | egrep '^\w+' | wc -l
1
0

## TESTS 1 - EXTENSIONLESS SHORTCUTS PT. 1
#perl- gives problems rn (tbf) 
$ alias perl-=""
$ GREP='grep'
# TODO: generate aliases for .sh and .perl scripts automatically
# ls *.sh *.perl | perl -pe "s/(\w+)\.\w+/alias \1='$&'/g; s/(\w+.perl)/perl- \1/g;" >| _all_alias.list
$ alias convert-termstrings='perl- convert_termstrings.perl'
$ alias do-rcsdiff='do_rcsdiff.sh'
$ alias dobackup='dobackup.sh'
$ alias kill-em='kill_em.sh'
$ alias kill-it='kill-em --pattern'

# # 1.1) NO EXAMPLES RN FOR kill-em and kill-it
# kill-em
# linebr
# kill-it
# # 1.2) TEST STOPS
# $ kill-em --pattern kcalc
# | pattern=/kcalc/
# | filter=/($)(^)/
# | OSTYPE: Undefined variable.

## 1.2) ERROR GENERATED - SCRIPT MISSING
# $ convert-termstrings
# | Can't open perl script "convert_termstrings.perl": No such file or directory

$ rm -rf ./*
$ printf "TOP\nTHIS IS A TEST\nBOTTOM" > test.txt
$ dobackup test.txt
$ linebr
$ ls
Backing up 'test.txt' to './backup/test.txt'
--------------------------------------------------------------------------------
backup	test.txt

## 1.3) do_rcsdiff
# $ do-rcsdiff Makefile
# | foreach: No match.

## BAD: alias ps-mine-='ps-mine "$@" | filter-dirnames'
$ function ps-mine- { ps-mine "$@" | filter-dirnames; }
$ alias ps_mine='ps-mine'
## DUP: alias ps-mine-='ps-mine "$@" | filter-dirnames'
$ alias ps-mine-all='ps-mine --all'

## ERROR - ps-mine COMMAND NOT FOUND
# ps_mine

$ alias rename-files='perl- rename_files.perl'
$ alias rename_files='rename-files'
$ alias testwn='perl- testwn.perl'
$ alias perlgrep='perl- perlgrep.perl'
$ alias foreach='perl- foreach.perl'
# rename-spaces: replace spaces in filenames of current dir with underscores
$ alias rename-spaces='rename-files -q global " " "_"'
#alias rename-quotes='rename-files -q -global "'"'"'" ""'   # where "'"'"'" is concatenated double quote, single quote, and double quote
$ alias rename-special-punct='rename-files -q -global -regex "[&\!\*?\(\)]" ""'
## TODO:
## alias rename-spaces='rename-files -rename_old -q -global " " "_"'
## alias rename-quotes='rename-files -rename_old -q -global "'"'"'" ""'   # where "'"'"'" is concatenated dou## OLD: alias rename-special-punct='rename-files -q -global -regex "[&\!\*?]" ""'

$ rm -rf ./*
$ touch abc.xyz def.xyz ooo.ppp
$ touch 'abc nounderscore.txt' abcdef\\.txt
$ ls
'abcdef\.txt'  'abc nounderscore.txt'   abc.xyz   def.xyz   ooo.ppp

#SINGLE FILE RENAME
$ rename_files -q ooo.ppp ooo.qqq
$ ls 
$ linebr
#EXTENSION RENAME 
$ rename_files -f .xyz .harry ./*
$ ls
$ linebr
#SPACES RENAME TO UNDERSCORES (need help)
$ rename-spaces -f
$ ls
$ linebr
#REMOVE SPECIAL CHARACTERS FROM FILENAME (need help)
$ rename-quotes -f 'abc nounderscore.txt'
$ ls
renaming "ooo.ppp" to "ooo.qqq"
'abcdef\.txt'  'abc nounderscore.txt'   abc.xyz   def.xyz   ooo.qqq
--------------------------------------------------------------------------------
renaming "./abc.xyz" to "./abc.harry"
renaming "./def.xyz" to "./def.harry"
'abcdef\.txt'   abc.harry  'abc nounderscore.txt'   def.harry   ooo.qqq
--------------------------------------------------------------------------------
WARNING: Ignoring -quick mode as files specified
'abcdef\.txt'   abc.harry  'abc nounderscore.txt'   def.harry   ooo.qqq
--------------------------------------------------------------------------------
bash: rename-quotes: command not found
'abcdef\.txt'   abc.harry  'abc nounderscore.txt'   def.harry   ooo.qqq

$ alias move-duplicates='mkdir -p duplicates; move *\([0-9]\).* duplicates 2>&1 | $GREP -iv cannot.stat.*..No.such'
$ alias rename-parens='rename-files -global -regex "[\(\)]" "" *[\(\)]*'
$ alias rename-etc='rename-spaces; rename-quotes; rename-special-punct; move-duplicates'

$ rm -rf ./*
# CREATING DUPLICATES 
$ touch 'abc(1).111' 'abc(2).111' 'xyz(3).111' 'xyz(4).111' '*abc.xyz' '&*abcdefg.xyz'
# REMOVES PARENTHESES () FROM FILENAMES
$ rename-parens
$ linebr
$ rename-special-punct
# rename-etc DOESN'T WORK WELL (move COMMAND NOT FOUND)
$ linebr
$ rename-etc
$ linebr
$ ls
renaming "abc(1).111" to "abc1.111"
renaming "abc(2).111" to "abc2.111"
renaming "xyz(3).111" to "xyz3.111"
renaming "xyz(4).111" to "xyz4.111"
--------------------------------------------------------------------------------
renaming "&*abcdefg.xyz" to "abcdefg.xyz"
renaming "*abc.xyz" to "abc.xyz"
--------------------------------------------------------------------------------
WARNING: Ignoring -quick mode as files specified
bash: rename-quotes: command not found
bash: move: command not found
--------------------------------------------------------------------------------
abc1.111  abc2.111  abcdefg.xyz  abc.xyz  duplicates  xyz3.111	xyz4.111

# move-log-files: move "versioned" log files to log-files
# move-output-files: likewise for output files with version numbers to ./output
# note: versioned files are those ending in numerics or with numeric affix
## TODO: use perl-style regex for more precise matching (effing over-arching glob's)
$ function move-versioned-files {
$     alias perl-grep='perl $BIN_DIR/perlgrep.perl'
$     alias dir-rw='dir -rw'
$     alias move='mv'
$     local ext_pattern="$1"
$     if [ "$ext_pattern" = "" ]; then ext_pattern="{list,log,txt}"; fi
$     local dir="$2"
$     if [ "$dir" = "" ]; then dir="versioned-files"; fi
$     mkdir -p "$dir";
$     local D="[-.]"
$     local file_list="$TEMP/_move-versioned-files-$$.list"
$     eval_middle="$(eval dir-rw *$D$ext_pattern[0-9]*  *$D*[0-9]*$D$ext_pattern  *$D$ext_pattern$D*[0-9][0-9]*   *$D*[0-9][0-9]*$D$ext_pattern  2>&1 | perl-grep -v 'No such file' | perl -pe 's/(\S+\s+){6}\S+//;' | sort -u)"
$     move "$eval_middle" "$dir"
$ }
$ alias move-log-files='move-versioned-files "{log,debug}" "log-files"'
# note: * the version regex should be kept quite specific to avoid useful files being moved into ./output
$ alias move-output-files='move-versioned-files "{csv,html,json,list,out,output,png,report,tsv,xml}" "output-files"'
$ alias move-adhoc-files='move-log-files; move-output-files'

# # SIMULATING THE CREATION OF LOG FILES AND OUTPUT FILES (need help)
# rm -rf ./*
# touch 'file1.log' 'file2.log' 'file3.debug' 'output1.html' 'output2.xml' 'output3.csv'
# move-log-files
# linebr
# move-output-files
# # OUTPUT
# mv: cannot stat 'dir:': No such file or directory
# mv: cannot stat 'invalid': No such file or directory
# mv: cannot stat 'line': No such file or directory
# mv: cannot stat 'width:': No such file or directory
# mv: cannot stat '‘*[-.]log[0-9]*’': No such file or directory
# --------------------------------------------------------------------------------
# mv: cannot stat 'dir:': No such file or directory
# mv: cannot stat 'invalid': No such file or directory
# mv: cannot stat 'line': No such file or directory
# mv: cannot stat 'width:': No such file or directory
# mv: cannot stat '‘*[-.]csv[0-9]*’': No such file or directory

# rename-with-file-date(file, ...): rename each file(s) with .ddMmmYY suffix
# Notes: 1. If file.ddMmmYY exists, file.ddMmmYY.N tried (for N in 1, 2, ...).
# 2. No warning is issued if the file doesn't exist, so can be used as a no-op.
# TODO: have option to put suffix before extension
# MISSING FUNCTION: get-free-filename
$ function get-free-filename() {
$     local base="$1"
$     local sep="$2"
$     local L=1
$     local filename="$base"
$     while [ -e "$filename" ]; do
$         let L++
$         filename="$base$sep$L"
$     done;
$     echo "$filename"
$ }
$ function rename-with-file-date() {
$     local f new_f
$     local move_command="move"
$     if [ "$1" = "--copy" ]; then
$         move_command='command cp --interactive --verbose --preserve'
$         shift
$     fi
$     for f in "$@"; do
$         if [ -e "$f" ]; then
$            new_f=$(get-free-filename "$f".$(date --reference="$f" '+%d%b%y') ".")
$            eval "$move_command" "$f" "$new_f";
$         fi
$     done;
$ }
## OLD: alias copy-with-file-date='rename-with-file-date --copy'
## HACK: See if function required for proper handling by bats-core
$ function copy-with-file-date { rename-with-file-date --copy "$@"; }
# ADDING DATES TO THE EXTENSION
$ rm -rf ./*
$ touch abc1.xyz abc2.xyz abc3.xyz abc4.xyz abc5.xyz.19Aug22 abc6.xyz.19Aug22
$ ls
$ linebr
$ copy-with-file-date *.xyz 
$ linebr
$ ls
abc1.xyz  abc2.xyz  abc3.xyz  abc4.xyz	abc5.xyz.19Aug22  abc6.xyz.19Aug22
--------------------------------------------------------------------------------
'abc1.xyz' -> 'abc1.xyz.03Oct22'
'abc2.xyz' -> 'abc2.xyz.03Oct22'
'abc3.xyz' -> 'abc3.xyz.03Oct22'
'abc4.xyz' -> 'abc4.xyz.03Oct22'
--------------------------------------------------------------------------------
abc1.xyz	  abc2.xyz.03Oct22  abc4.xyz	      abc6.xyz.19Aug22
abc1.xyz.03Oct22  abc3.xyz	    abc4.xyz.03Oct22
abc2.xyz	  abc3.xyz.03Oct22  abc5.xyz.19Aug22

# Statistical helpers
$ alias bigrams='perl -sw $BIN_DIR/count_bigrams.perl -N=2'
$ alias unigrams='perl -sw $BIN_DIR/count_bigrams.perl -N=1'
$ alias word-count=unigrams

$ rm -rf ./*
$ uname -r > catmanual.txt
$ bigrams catmanual.txt
$ ls
$ word-count catmanual.txt
$ ls
n/a:n/a	1
catmanual.txt
n/a	1
catmanual.txt

# Lynx stuff
# lynx-dump-stdout(option, ...): Run lynx with textual output to stdout
# lynx-dump(file, [[out-file], option, ...]): Run lynx over base.html with output to base.txt
$ lynx-dump-stdout () { lynx -width=512 -dump "$@"; }
$ lynx-dump () { 
$     local in_file="$1"
$     shift 1
$     local base=$(basename "$file" .html)
$     if [[ ("$out_file" = "" ) && (! "$1" =~ -*) ]]; then
$         local out_file="$1"
$     fi
$     if [ "$out_file" = "" ]; then out_file="$base.txt"; fi
$     lynx-dump-stdout "$@" "$file" > "$out_file" 2> "$out_file.log"
$     if [ -s "$out_file.log" ]; then
$         cat "$out_file.log"
$         delete-force "$out_file.log"
$     fi
$ }
$ if [ "$BAREBONES_HOST" = "1" ]; then export lynx_width=0; fi
$ alias lynx-html='lynx -force_html'

# TROUBLES WITH BATSPP
# $ lynx-dump-stdout | head

#lynx-html (is a continuously running program)
$ printf "https://www.google.com/" > lynxin.txt
# lynx-dump lynxin.txt (need help)

# CSH-like aliases
#
$ function setenv () { export $1="$2"; }
$ alias unsetenv='unset'
$ alias unexport='unset'

$ setenv MY_USERNAME aveey-temp
$ echo $MY_USERNAME
$ linebr
$ unexport MY_USERNAME
$ echo $MY_USERNAME
aveey-temp
--------------------------------------------------------------------------------


# Unicode support
#
# TODO: put show-unicode-code-info-aux into script (as with other overly-large function definitions like hg-pull-and-update)
# show-unicode-control-chars(): output Unicode codepoint (ordinal) and UTF-8 encoding for input chars with offset in line
$ function show-unicode-code-info-aux() { perl -CIOE   -e 'use Encode "encode_utf8"; print "char\tord\toffset\tencoding\n";'    -ne 'chomp;  printf "%s: %d\n", $_, length($_); foreach $c (split(//, $_)) { $encoding = encode_utf8($c); printf "%s\t%04X\t%d\t%s\n", $c, ord($c), $offset, unpack("H*", $encoding); $offset += length($encoding); }   $offset += length($/); print "\n"; ' < "$1"; }
$ function show-unicode-code-info { show-unicode-code-info-aux "$@"; }
$ function show-unicode-code-info-stdin() { in_file="$TEMP/show-unicode-code-info.$$"; cat >| $in_file;  show-unicode-code-info-aux $in_file; }
#
$ function output-BOM { perl -e 'print "\xEF\xBB\xBF\n";'; }
#
# show-unicode-control-chars(): Convert ascii control characters to printable Unicode ones (e.g., ␀ for 0x00)
## BAD: function show-unicode-control-chars { perl -pe 'use Encode "decode_utf8"; s/[\x00-\x1F]/chr($&+0x2400)/e;'; }
# See https://stackoverflow.com/questions/42193957/errorwide-character-in-print-at-x-at-line-35-fh-read-text-files-from-comm.
## BAD: function show-unicode-control-chars { perl -pe 'use open ":std", ":encoding(UTF-8)"; s/[\x00-\x1F]/chr($& + 0x2400)/eg;'; }
$ function show-unicode-control-chars { perl -pe 'use open ":std", ":encoding(UTF-8)"; s/[\x00-\x1F]/chr(ord($&) + 0x2400)/eg;'; }

# ## UNICODE ALIASES (need help for implementation)
# show-unicode-code-info-aux
# show-unicode-code-info
# show-unicode-code-info-stdin
# output-BOM
# show-unicode-control-chars

$ show-unicode-code-info-aux ./catmanual.txt
char	ord	offset	encoding
5.15.0-48-generic: 17
5	0035	0	35
.	002E	1	2e
1	0031	2	31
5	0035	3	35
.	002E	4	2e
0	0030	5	30
-	002D	6	2d
4	0034	7	34
8	0038	8	38
-	002D	9	2d
g	0067	10	67
e	0065	11	65
n	006E	12	6e
e	0065	13	65
r	0072	14	72
i	0069	15	69
c	0063	16	63


$ show-unicode-code-info ./catmanual.txt
char	ord	offset	encoding
5.15.0-48-generic: 17
5	0035	0	35
.	002E	1	2e
1	0031	2	31
5	0035	3	35
.	002E	4	2e
0	0030	5	30
-	002D	6	2d
4	0034	7	34
8	0038	8	38
-	002D	9	2d
g	0067	10	67
e	0065	11	65
n	006E	12	6e
e	0065	13	65
r	0072	14	72
i	0069	15	69
c	0063	16	63


# # ERROR GENERATED (shown below)
# $ show-unicode-code-info-stdin ./catmanual.txt
# | bash: /show-unicode-code-info.5292: Permission denied
# | bash: /show-unicode-code-info.5292: No such file or directory

# ERROR GENERATED (non-ending process; need help)
# $ show-unicode-control-chars ./catmanual.txt

## NO OUTPUT GENERATED
# output-BOM ./catmanual.txt

$ echo "END"
END
