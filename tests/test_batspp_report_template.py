#! /usr/bin/env python3
# Tests for batspp_report.py module

"""Tests for batspp_report.py module"""

# Standard packages
import unittest
import re

# Installed packages
import pytest

# Local packages
from mezcla.unittest_wrapper import TestWrapper
from mezcla import glue_helpers as gh
from mezcla import debug
from mezcla.main import Main
from mezcla import system
from mezcla.my_regex import my_re

import batspp_report as THE_MODULE

SCRIPT = gh.resolve_path("batspp_report.py")

## Optional:
## # Increase trace level for regex searching, etc. (e.g., from 6 to 7)
## my_re.TRACE_LEVEL = debug.QUITE_VERBOSE
debug.trace(5, f"global __doc__: {__doc__}")
debug.assertion(__doc__)

TODO_ARG = "TODO-arg"

# Constants
TL = debug.TL

# Environment options
TODO_FUBAR = system.getenv_bool("TODO_FUBAR", False,
                                description="TODO: Fouled Up Beyond All Recognition processing")

# Test CLass with run_script()
class TestBatsppReportScript(Main):
    """Input processing class"""
    todo_arg = False
    
    def setup(self):
        """Check results of command line processing"""
        # debug.trace_fmtd(TL.VERBOSE, "Script.setup(): self={s}", s=self)
        # self.todo_arg = self.get_parsed_option(TODO_ARG, self.todo_arg)
        debug.trace_object(5, self, label=f"{self.__class__.__name__} instance")
        self.main_obj = Main()
        self.main_obj.setup()

    def process_line(self, line):
        """Processes current line from input"""
        debug.trace_fmtd(TL.QUITE_DETAILED, "Script.process_line({l})", l=line)
        # TODO: flesh out
        if self.todo_arg and "TODO" in line:
            print(f"arg1 line ({self.line_num}): {line}")
        else:
            debug.trace(3, f"Ignoring line ({self.line_num}): {line}")

class TestBatsppReportDirect(TestWrapper):
    """Class for testcase defintion"""
    script_file = TestWrapper.get_module_file_path(__file__)
    script_module = TestWrapper.get_testing_module_name(__file__)
    use_temp_base_dir = True

    def test_txt_report_format(self):
        """Tests txt report format"""
        txt_report_format = r"(\d+) out of (\d+) successful"
        txt_report_from_dir = gh.read_lines("txt-reports/hello-world.txt")
        txt_report_search_cond = [
            "True" for line in txt_report_from_dir if re.search(txt_report_format, line)
        ].pop(0)
        # TODO/(BUG?): my_re.search returns NoneType, find a way to return bool
        self.assertEqual(txt_report_search_cond, "True")

    def test_no_report_option(self):
        """Tests no report option"""
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --no > {self.temp}")
        no_report_command_output = gh.read_lines(self.temp)
        no_report_indicator = ">> SKIPPING BATSPP CHECK (-n ARGUMENT PROVIDED)"
        # LACKING: assertEqual cannot compare other types than "str"
        is_no_report = str(
            "True" if no_report_indicator in no_report_command_output else "False"
        )
        self.assertEqual(is_no_report, "True")

    def test_count_avoided_testfiles(self):
        """Tests counts of avoided testfiles"""
        # Atleast one test has "NOBATSPP" suffix
        # TODO: Use my_re instead of re for pattern searching
        avoided_pattern = r"No\. of AVOIDED testfiles: (\d+)"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --no > {self.temp}")
        command_output = gh.read_lines(self.temp)
        count_avoided_testfiles_statement = [
            line for line in command_output if re.search(avoided_pattern, line)
        ].pop(0)
        count_avoided_testfiles = int(count_avoided_testfiles_statement[-1])
        is_avoided_testfiles = "True" if count_avoided_testfiles != 0 else "False"
        self.assertEqual(is_avoided_testfiles, "True")

    def test_count_all_testfiles(self):
        """Tests counts of all testfiles"""
        # Complement process of test_count_avoided_testfiles
        avoided_pattern = r"No\. of AVOIDED testfiles: (\d+)"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --no --all > {self.temp}")
        command_output = gh.read_lines(self.temp)
        count_avoided_testfiles_statement = [
            line for line in command_output if my_re.search(avoided_pattern, line)
        ].pop(0)
        count_avoided_testfiles = int(count_avoided_testfiles_statement[-1])
        is_avoided_testfiles = "True" if count_avoided_testfiles == 0 else "False"
        self.assertEqual(is_avoided_testfiles, "True")

    def test_warnings(self):
        """Tests warning generated by script"""
        warning_message = "Error: running under admin account requires --force option"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --no > {self.temp} 2>&1")
        command_output = gh.read_lines(self.temp)
        self.assertEqual(command_output.pop(0), warning_message)

    @pytest.mark.xfail
    def test_kcov_reports(self):
        """Tests kcov report generation"""
        ## WORK-IN-PROGRESS
        assert (False)

    def test_switch_option(self):
        """Tests --switch options in script"""
        switch_pattern = "simple_batspp.py used:"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --switch > {self.temp}")
        command_output = gh.read_lines(self.temp)
        switch_statement = [
            line for line in command_output if re.search(switch_pattern, line)
        ].pop(0)
        switch_statement_result = (
            switch_statement[switch_statement.rfind(" ") + 1 :]
            if " " in switch_statement
            else switch_statement
        )
        self.assertEqual(switch_statement_result, "True")

    @pytest.mark.xfail
    def test_env_variables(self):
        """Tests environment variables in script"""
        assert (False)


def main():
    """Entry point"""
    app = TestBatsppReportScript(
        description=__doc__.format(script=__file__),
        skip_input=False,
        manual_input=False,
        boolean_options=[(TODO_ARG, "TODO-desc")],
        float_options=None)
    app.run()
    # Make sure no TODO_vars above (i.e., in namespace)
    debug.assertion(not any(my_re.search(r"^TODO_", m, my_re.IGNORECASE)
                            for m in dir(app)))    
    
#-------------------------------------------------------------------------------
    
if __name__ == '__main__':
    debug.trace_current_context(level=TL.QUITE_VERBOSE)
    debug.trace(5, f"main __doc__: {main.__doc__}")
    debug.assertion("TODO:" not in __doc__)
    main()
