# Setup
$ bind 'set enable-bracketed-paste off'

## TEST:  Make sure simple prompt used (e.g., no escapes that might contaminate output)
## PS1="$ "
## TODO: PS1="> "
## NOTE: The Jupyter bash kernel requires that PS1 not be modified as they customize it. 
$ echo $PS1
[PEXP\[\]ECT_PROMPT>

# Delete all aliases and function
# TODO: Instead start from pristine environment
$ unalias -a
$ alias | wc -l
$ for f in $(typeset -f | egrep '^\w+'); do unset -f $f; done
$ typeset -f | egrep '^\w+' | wc -l
0
0

# Setting a temp directory for tests
$ TMP=/tmp/test-trace-misc
## NOTE: Source it directly from the ./tests directory.
$ BIN_DIR=$PWD/..
## You will need to run jupyter from that directory.
## source $TEMP_BIN/_dir-aliases.bash
$ source _dir-aliases.bash
$ alias | wc -l
8

## NOTE: For reproducability, the directory name needs to be fixed
## In place of $$, use a psuedo random number (e,g., 1210)
## *** All output from one run to the next needs to be the same ***
## temp_dir=$TMP/test-$$
$ temp_dir=$TMP/test-1210
$ mkdir -p "$temp_dir"
# TODO: /bin/rm -rvf "$temp_dir"
$ cd "$temp_dir"
$ pwd
#ALIAS FOR PRINTING SEPERATION LINES (FOR JUPYTER)
$ alias linebr="printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -"
/tmp/test-trace-misc/test-1210

# Count aliases proper
$ alias | wc -l
9

# Count functions
$ typeset -f | egrep '^\w+' | wc -l
2

##1 SHOWS HISTORY OF BASH COMMANDS
$ alias hist='history $LINES'
$ hist
 2013  source _dir-aliases.bash
 2014  alias | wc -l
 2015  echo $?
 2016  ## NOTE: For reproducability, the directory name needs to be fixed
 2017  ## In place of $$, use a psuedo random number (e,g., 1210)
 2018  ## *** All output from one run to the next needs to be the same ***
 2019  ## temp_dir=$TMP/test-$$
 2020  temp_dir=$TMP/test-1210
 2021  mkdir -p "$temp_dir"
 2022  # TODO: /bin/rm -rvf "$temp_dir"
 2023  cd "$temp_dir"
 2024  pwd
 2025  #ALIAS FOR PRINTING SEPERATION LINES (FOR JUPYTER)
 2026  alias linebr="printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -"
 2027  echo $?
 2028  # Count aliases proper
 2029  alias | wc -l
 2030  echo $?
 2031  # Count functions
 2032  typeset -f | egrep '^\w+' | wc -l
 2033  echo $?
 2034  ##1 SHOWS HISTORY OF BASH COMMANDS
 2035  alias hist='history $LINES'
 2036  hist

##2 SHOWS HISTORY WITHOUT TIMESTAMPS
# Removes timestamp from history (e.g., " 1972  [2014-05-02 14:34:12] dir *py" => " 1972  dir *py")
# TEST: function hist { h | perl -pe 's/^(\s*\d+\s*)(\[[^\]]+\])(.*)/$1$3/;'; }
# note: funciton used to simplify specification of quotes
# quiet-unalias h #COMMAND NOT FOUND
$ function h { hist | perl -pe 's/^(\s*\d+\s*)(\[[^\]]+\])(.*)/$1$3/;'; }
$ h
 2021  mkdir -p "$temp_dir"
 2022  # TODO: /bin/rm -rvf "$temp_dir"
 2023  cd "$temp_dir"
 2024  pwd
 2025  #ALIAS FOR PRINTING SEPERATION LINES (FOR JUPYTER)
 2026  alias linebr="printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -"
 2027  echo $?
 2028  # Count aliases proper
 2029  alias | wc -l
 2030  echo $?
 2031  # Count functions
 2032  typeset -f | egrep '^\w+' | wc -l
 2033  echo $?
 2034  ##1 SHOWS HISTORY OF BASH COMMANDS
 2035  alias hist='history $LINES'
 2036  hist
 2037  echo $?
 2038  ##2 SHOWS HISTORY WITHOUT TIMESTAMPS
 2039  # Removes timestamp from history (e.g., " 1972  [2014-05-02 14:34:12] dir *py" => " 1972  dir *py")
 2040  # TEST: function hist { h | perl -pe 's/^(\s*\d+\s*)(\[[^\]]+\])(.*)/$1$3/;'; }
 2041  # note: funciton used to simplify specification of quotes
 2042  # quiet-unalias h #COMMAND NOT FOUND
 2043  function h { hist | perl -pe 's/^(\s*\d+\s*)(\[[^\]]+\])(.*)/$1$3/;'; }
 2044  h

##3 ASCTIME
# EX: $ asctime | perl -pe 's/\d/N/g; s/\w+ \w+/DDD MMM/;' => "DDD MMM NN NN:NN:NN NNNN"
$ function asctime() { perl -e "print (scalar localtime($1));"; echo ""; }
$ asctime | perl -pe 's/\d/N/g; s/\w+ \w+/DDD MMM/;'
DDD MMM NN NN:NN:NN NNNN

##4 FILTER DIRECTORY NAMES
# filter-dirnames: strip directory names from ps listing (TODO: rename as strip-dirnames)
$ function filter-dirnames () { perl -pe 's/\/[^ \"]+\/([^ \/\"]+)/$1/g;'; }
$ ps | filter-dirnames
    PID TTY          TIME CMD
  27306 pts/2    00:00:00 bash
  27335 pts/2    00:00:00 ps
  27336 pts/2    00:00:00 bash
  27337 pts/2    00:00:00 perl

##5 COMMAIZE NUMBERS
# comma-ize-number(): add commas to numbers in stdin
# EX: echo "1234567890" | comma-ize-number => 1,234,567,890
$ function comma-ize-number () { perl -pe 'while (/\d\d\d\d/) { s/(\d)(\d\d\d)([^\d])/\1,\2\3/g; } '; }
$ echo "99012342305324254" | comma-ize-number
99,012,342,305,324,254

##6 APPLYING NUMERIC SUFFIXES
# apply-numeric-suffixes([once=0]): converts numbers in stdin to use K/M/G suffixes.
# Notes:
# - K, M, G and T based on powers of 1024.
# - If $once non-zero, then the substitution is only applied one-time per line.
# - The number must be preceded by a word boundary and followed by whitespace.
# This was added in support of the usage function (e.g., numeric subdirectory names).
# TODO:
# - Convert to Perl script to avoid awkward bash command line construction.
# - Make the trailing context a word-boundry as well (rather than whitespace).
# EX: echo "1024 1572864 1073741824" | apply-numeric-suffixes => 1K 1.5M 1G
# EX: echo "1024 1572864 1073741824" | apply-numeric-suffixes 1 => 1K 1572864 1073741824
$ function apply-numeric-suffixes () {
$     local just_once="$1"
$     local g="g";
$     if [ "$just_once" = "1" ]; then g=""; fi
$     # TODO: make only sure the first number is converted if just-once applies
$     # NOTE: 3 args to sprintf: coefficient, KMGT suffix, and post-context
$     ## DEBUG; perl -pe '$suffixes="_KMGT";  s@\b(\d{4,15})(\s)@$pow = log($1)/log(1024);  $new_num=($1/1024**$pow);  $suffix=substr($suffixes, $pow, 1);  print STDERR ("s=$suffixes p=$pow nn=$new_num l=$suffix\n"); sprintf("%.3g%s%s", $new_num, $suffix, $2)@e'"$g;"
$     perl -pe '$suffixes="_KMGT";  s@\b(\d{4,15})(\s)@$pow = int(log($1)/log(1024));  $new_num=($1/1024**$pow);  $suffix=substr($suffixes, $pow, 1);  sprintf("%.3g%s%s", $new_num, $suffix, $2)@e'"$g;"
$ }
# TESTED COMMAND (if 1 KB ~ 1000 B; must return 7.XX GB (~ 8 GB) )
$ echo "8000000000" | apply-numeric-suffixes
7.45G

##6.1 APPLYING USAGE NUMERIC SUFFIXES
# apply-usage-numeric-suffixes(): factors in 1k blocksize before applying numeric suffixes
# note: (?=\s) is lookahead pattern (see perlre manpage)
#
$ function apply-usage-numeric-suffixes() {
$     perl -pe 's@^(\d+)(?=\s)@$1 * 1024@e;' | apply-numeric-suffixes 1
$ }
# IN SHORT = result * 1000
$ echo "8000000000" | apply-usage-numeric-suffixes #G -> T
$ echo "8000000" | apply-usage-numeric-suffixes #M -> G
7.45T
7.63G

#7 usage-pp
$ function usage {
$     ## TODO: output_file=(("$1"||"usage.list"));
$     output_file=$(default_assignment "$1" "usage.list")
$     rename-with-file-date "$output_file";
$     $NICE du --block-size=1K --one-file-system 2>&1 | $NICE sort -rn | apply-usage-numeric-suffixes >| $output_file 2>&1;
$     $PAGER $output_file;
$ }
$ function usage-alt {
$     local output_file=$TEMP/$(basename $PWD)"-usage.list";
$     usage "$output_file"
$ }
$ function byte-usage () { output_file="usage.bytes.list"; backup-file $output_file; $NICE du --bytes --one-file-system 2>&1 | $NICE sort -rn | apply-usage-numeric-suffixes >| $output_file 2>&1; $PAGER $output_file; }
## TODO: function usage () { du --one-file-system --human-readable 2>&1 | sort -rn >| usage.list 2>&1; $PAGER usage.list; }
#TODO: rework so that pp version saved in file
$ alias usage-pp='usage | apply-usage-numeric-suffixes | $PAGER'
#

# ERROR GENERATED- MULTIPLE
# $ ups a > psa.txt
# $ usage psa.txt
# | bash: ups: command not found
# | bash: default_assignment: command not found
# | bash: rename-with-file-date: command not found
# | bash: $output_file: ambiguous redirect
# | sort: fflush failed: 'standard output': Broken pipe
# | sort: write error

#8 number-columns(file): number each column in first line of tabular file
$ function number-columns () { head -1 "$1" | perl -0777 -pe '$c = 1; s/^/1: /; s/\t/"\t" . ++$c . ": "/eg;'; }
# TODO: s/\t/\\t/g;
$ function number-columns-comma () { head -1 "$1" | perl -pe 's/,/\t/g;' | number-columns -; }

#8.1) 
$ rm -rf ./*
$ mkdir backup
$ printf "THIS IS THE START\nTHIS IS A TEST\nTHIS IS A TEST\nTHIS IS A TEST\nTHIS IS A TEST\nTHIS IS A TEST\nTHIS IS THE END\n" > thisisatest.txt
$ ps aux > process.txt
$ number-columns thisisatest.txt
$ number-columns-comma process.txt
1: THIS IS THE START
1: USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND

#9) reverse REVERSES cat COMMAND
# alias type='cat'  # interferes with type command
$ alias reverse='tac'
$ cat thisisatest.txt
$ linebr
$ reverse thisisatest.txt
THIS IS THE START
THIS IS A TEST
THIS IS A TEST
THIS IS A TEST
THIS IS A TEST
THIS IS A TEST
THIS IS THE END
--------------------------------------------------------------------------------
THIS IS THE END
THIS IS A TEST
THIS IS A TEST
THIS IS A TEST
THIS IS A TEST
THIS IS A TEST
THIS IS THE START

#10) backup-file
$ function backup-file () { local file="$1"; if [ -e "$file" ]; then dobackup.sh "$file"; fi; }
## TODO: output header (e.g., "num-blocks<TAB>dir    # note: blocksize is 1k")
#

# ERROR - NEED A CHANGE OF PATH (TBF) ==solved==
$ backup-file thisisatest.txt
# bash: /home/aveey/bin/dobackup.sh: /bin/csh: bad interpreter: No such file or directory
Backing up 'thisisatest.txt' to './backup/thisisatest.txt'

$ function byte-usage () { output_file="usage.bytes.list"; backup-file $output_file; $NICE du --bytes --one-file-system 2>&1 | $NICE sort -rn | apply-usage-numeric-suffixes >| $output_file 2>&1; $PAGER $output_file; }
## TODO: function usage () { du --one-file-system --human-readable 2>&1 | sort -rn >| usage.list 2>&1; $PAGER usage.list; }

# ERROR - NEED CHANGE OF PATH (TBF) ==solved==
$ byte-usage process.txt
# | bash: /home/aveey/bin/dobackup.sh: /bin/csh: bad interpreter: No such file or directory
# | 30.4M	.
# (Same output for 'byte-usage "Hi Mom"' and 'byte-usage thisisatest.txt')
36M	.
4.11M	./backup

# check[all-]-(errors|warnings): check for known errors, with the check-all
# variant including more patterns and with warnings subsuming errors.
## OLD:
## function check-errors () { (check_errors.perl -context=5 "$@") 2>&1 | $PAGER; }
## function check-all-errors () { (check_errors.perl -warnings -relaxed -context=5 "$@") 2>&1 | $PAGER; }
$ function check-errors () { (DEBUG_LEVEL=1 check_errors.perl -context=5 "$@") 2>&1 | $PAGER; }
$ function check-all-errors () { (DEBUG_LEVEL=1 check_errors.perl -warnings -relaxed -context=5 "$@") 2>&1 | $PAGER; }
$ alias check-warnings='echo "*** Error: use check-all-errors instead ***"; echo "    check-all-errors"'
$ alias check-all-warnings='check-all-errors -strict'
#
# check-errors-excerpt(log-file): show errors are start of log-file and at end if different
$ function check-errors-excerpt () {
$     local base="$TMP/check-errors-excerpt-$$"
$     local head="$base.head"
$     local tail="$base.tail"
$     check-errors "$@" | head >| $head;
$     cat "$head"
$     check-errors "$@" | tail >| $tail;
$     diff "$head" "$tail" >| /dev/null
$     if [ $? != 0 ]; then
$         echo "\$?=$?"
$         cat "$tail";
$     fi
$ }

#11 - LOG FILES ARE REQUIRED FOR check-errors
$ check-errors process.txt
$ check-all-errors process.txt
$ linebr
$ check-warnings
$ linebr
$ check-all-warnings
$ linebr
$ check-errors-excerpt process.txt
process.txt
process.txt
--------------------------------------------------------------------------------
*** Error: use check-all-errors instead ***
    check-all-errors
--------------------------------------------------------------------------------

usage: check_errors.perl [options]

options = [-warnings] [-context=N] [-no_astericks] [-skip_ruby_lib] [-relaxed | -strict]

ex: check_errors.perl whatever


Notes:
- The default context is 1
- Warnings are skipped by default
- Use -no_astericks if input uses ***'s outside of error contexts
Use -relaxed to exclude special cases (e.g., xyz='error')

--------------------------------------------------------------------------------
process.txt

$ function tkdiff () { wish -f $BIN_DIR/tkdiff.tcl "$@" & }
$ alias rdiff='rev_vdiff.sh'
$ alias tkdiff-='tkdiff -noopt'
$ function kdiff () { kdiff.sh "$@" & }
$ alias vdiff='kdiff'

# # 12) rdiff, tkdiff, vdiff - ERROR IN COMMANDS (as shown)
# $ rdiff process.txt psa.txt
# $ linebr
# $ tkdiff- process.txt psa.txt
# $ linebr
# $ vdiff process.txt 
# | Echo: Command not found.
# | ???
# | cvs: Command not found.
# | 
# | echo: No match.
# | echo: No match.
# | issuing: tkdiff.tcl -r.-1 process.txt
# | [1] 5609
# | tkdiff.tcl: Command not found.
# | --------------------------------------------------------------------------------
# | bash: tkdiff: command not found
# | --------------------------------------------------------------------------------
# | [1] 5615

# ERRORS UPDATED 
# $ tkdiff process.txt psa.txt
#   linebr
#   vdiff process.txt psa.txt
#   linebr
#   rdiff process.txt 
#   linebr
# | [1] 6322
# | --------------------------------------------------------------------------------
# | Error in startup script: couldn't read file "/home/aveey/tom-project/shell-scripts/tests/../tkdiff.tcl": no such file or directory
# | [2] 6325
# | [1]   Exit 1                  wish -f $BIN_DIR/tkdiff.tcl "$@"
# | /home/aveey/bin/kdiff.sh: line 56: /kdiff-6325.log: Permission denied
# | --------------------------------------------------------------------------------
# | [2]+  Done                    kdiff.sh "$@"
# | Echo: Command not found.
# | ???
# | cvs: Command not found.
# | 
# | echo: No match.
# | echo: No match.
# | issuing: tkdiff.tcl -r.-1 process.txt
# | [1] 6364
# | tkdiff.tcl: Command not found.
# | --------------------------------------------------------------------------------

# diff(): run diff command w/ --ignore-all-space (-w) and --ignore-space-change (-b)
$ diff_options="--ignore-space-change --ignore-blank-lines"
$ alias diff='command diff $diff_options'
$ alias diff-default='command diff'
$ alias diff-ignore-spacing='diff --ignore-all-space'
#
# do-diff(): wrapper into do_diff.sh, which allows for glob patterns of current vs target dirs
$ alias do-diff='do_diff.sh'
#
$ function diff-rev () {
$     local diff_program="diff"
$     if [ "$1" = "--diff-prog" ]; then
$         diff_program="$2"
$         shift 2
$     fi
$     local right_file="$1"
$     local left_file="$2"
$     ## OLD: if [ -d "$left_file" ]; then left_file="$left_file/$right_file"; fi
$     if [ -d "$left_file" ]; then left_file="$left_file"/$(basename "$right_file"); fi
$     # TODO: create helper for resolving one file relative to dir of another
$     ## BAD: if [ ! -e "$left_file" ]; then left_file=$(dirname "$right_file")/"$left_file"; fi
$     "$diff_program" "$left_file" "$right_file"
$ }
$ alias kdiff-rev='diff-rev --diff-prog kdiff'
$ alias diff-log-output='compare-log-output.sh'
$ alias vdiff-rev=kdiff-rev

# # TESTING diff COMMANDS
# # EVERY DIFF COMMANDS WORK NORMALLY, BUT TESTS HALT AFTER
$ rm -rf ./*
$ mkdir backup
# linebr
$ ps -u > process1.txt
$ ps -u > process2.txt

# #1) diff - HALTS PROCESS (WORKS FINE)
# $ diff process1.txt process2.txt #(DIFFERENTIATING PROCESSES FOR DIFFERENT INSTANCES)

# #2) diff-default - HALTED (WORKS FINE)
# $ diff-default process1.txt process2.txt

# #3) diff-ignore-spacing -HALTED (WORKS FINE)
# $ diff-ignore-spacing process1.txt process2.txt

# #4) do-diff - HALTED (WORKS FINE)
# $ do-diff process1.txt process2.txt

# #5) kdiff-rev & vdiff-rev PERFORM THE SAME TASK - HALTS (WORKS FINE)
# $ kdiff-rev process1.txt process2.txt
# linebr
# $ vdiff-rev process1.txt process2.txt

# 6) diff-log-output
# $ ls
# $ linebr
# $ diff-log-output logger1.log logger2.log
# ERROR GENERATED TO BE FIXED
# bash: completion: function `_completion_loader' not found (COMPLETE COMMENT FILE RETURNS THIS)

$ echo "THIS IS A NOICE SIGNATURE" > $HOME/info/.noice-signature

$ function signature () {
$     if [ "$1" = "" ]; then
$         $LS "$HOME/info/.$1-signature"
$         echo "Usage: signature dotfile-prefix"
$         echo "ex: signature scrappycito"
$         return;
$     fi
$     ## TODO: echo filename and then cat??
$     local filename="$HOME/info/.$1-signature"
$     echo "$filename:"
$     cat "$filename"
$ }
$ alias cell-signature='signature cell'
$ alias home-signature='signature home'
$ alias po-signature='signature po'
$ alias tpo-signature='signature tpo'
$ alias tpo-scrappycito-signature='signature tpo-scrappycito'
$ alias scrappycito-signature='signature scrappycito'
$ alias farm-signature='signature farm'
$ alias circulo-signature='signature circulo'
# TODO: automatically derive aliases for ~/info/*.signature*

$ signature noice
/home/aveey/info/.noice-signature:
THIS IS A NOICE SIGNATURE

# most-recent-backup(file): returns most recent backup for FILE in ./backup, accounting for revisions (e.g., extract_matches.perl.~4~)
$ function most-recent-backup {
$     if [ "$1" = "" ]; then
$         echo "usage: most-recent-backup filename"
$         echo "use BACKUP_DIR=dir ... to override use of ./backup"
$         return
$     fi
$     local file="$1";
$     local dir="$BACKUP_DIR"; if [ "$dir" = "" ]; then dir=./backup; fi
$     ## TODO: $LS -t $dir/* | $EGREP "/$file(~|.~*)" | head -1;
$     $LS -t $dir/* | /bin/egrep "/$file(~|.~*)?" | head -1;
$ }
#
# diff-backup(file): compare FILE vs. most recent backup
$ function diff-backup-helper {
$     local diff="$1"; local file="$2"; 
$     "$diff" $(most-recent-backup "$file") "$file";
$ }
$ alias diff-backup='diff-backup-helper diff'
$ alias kdiff-backup='diff-backup-helper kdiff'

$ dobackup.sh process1.txt
$ linebr
$ most-recent-backup process1.txt
$ linebr
$ ps -u > process1.txt
Backing up 'process1.txt' to './backup/process1.txt'
--------------------------------------------------------------------------------
./backup/process1.txt
--------------------------------------------------------------------------------

## WORKS FINE - HALTS THE NOTEBOOK TESTS
# $ diff-backup process1.txt

## WORKS FINE - HALTS THE NOTEBOOK TESTS
# $ kdiff-backup process1.txt

$ echo "Done"
Done
