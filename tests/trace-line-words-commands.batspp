## Bracketed Paste is disabled to prevent characters after output
## Example: 
# $ echo 'Hi'
# | Hi?2004l
$ bind 'set enable-bracketed-paste off'
[?2004h[?2004l[?2004l[?2004l[?2004l[?2004l

## TEST:  Make sure simple prompt used (e.g., no escapes that might contaminate output)
## PS1="$ "
## TODO: PS1="> "
## NOTE: The Jupyter bash kernel requires that PS1 not be modified as they customize it. 
$ echo $PS1
[PEXP\[\]ECT_PROMPT>

# Delete all aliases and function
# TODO: Instead start from pristine environment
$ unalias -a
$ alias | wc -l
$ for f in $(typeset -f | egrep '^\w+'); do unset -f $f; done
$ typeset -f | egrep '^\w+' | wc -l
0
0

# Setting a temp directory for tests
$ TMP=/tmp/test-linewords
## NOTE: Source it directly from the ./tests directory.
$ BIN_DIR=$PWD/..
$ alias | wc -l
0

## NOTE: For reproducability, the directory name needs to be fixed
## In place of $$, use a psuedo random number (e,g., 6439)
## *** All output from one run to the next needs to be the same ***
## temp_dir=$TMP/test-$$
$ temp_dir=$TMP/test-6439
$ mkdir -p "$temp_dir"
# TODO: /bin/rm -rvf "$temp_dir"
$ cd "$temp_dir"
$ pwd
#ALIAS FOR PRINTING SEPERATION LINES (FOR JUPYTER)
$ alias linebr="printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -"
/tmp/test-linewords/test-6439

# Count aliases proper
$ alias | wc -l
# Count functions
$ typeset -f | egrep '^\w+' | wc -l
1
0

## TEST 1 - TRACE LINE/WORD COUNT COMMANDS
$ alias count-it="count_it.perl"
# line-wc; alias for counting words on individual lines thoughout a file
# (Gotta hate csh)
$ function line-wc () { perl -n -e '@_ = split; printf("%d\t%s", 1 + $#_, $_);' "$@"; }
$ alias line-word-len='line-wc'
# 
$ function line-len () { perl -ne 'printf("%d\t%s", length($_) - 1, $_);' "$@"; }
$ function para-len () { perl -00 -ne 'printf("%d\t%s", length($_) - 1, $_);' "$@"; }
$ alias ls-line-len='ls | line-len | sort -rn | less'  #'$LS | line-len | sort -rn | less'
$ function check-class-dist () { count-it "^(\S+)\t" "$1" | perl- calc_entropy.perl -; }
$ alias 2bib='bibitem2bib'

# GENERATES A PARAGRAPH WITH MULTIPLE LINES
$ printf "Hi Mom,\nThis is the use of printf\nI can use a backslash n to start a new line\n1\n2\n3"> abc-test.txt

# line-wc | COUNTS WORD FOR EACH LINE
$ cat abc-test.txt | line-wc
2	Hi Mom,
6	This is the use of printf
11	I can use a backslash n to start a new line
1	1
1	2
1	3

# line-len | COUNTS CHARACTERS FOR EACH LINE
$ cat abc-test.txt | line-len
7	Hi Mom,
25	This is the use of printf
43	I can use a backslash n to start a new line
1	1
1	2
0	3

# para-len | COUNTS CHARACTERS FOR EACH PARAGRAPH
$ cat abc-test.txt | para-len
82	Hi Mom,
This is the use of printf
I can use a backslash n to start a new line
1
2
3

# line-word-len | COUNTS WORDS FOR EACH LINE
$ cat abc-test.txt | line-word-len
2	Hi Mom,
6	This is the use of printf
11	I can use a backslash n to start a new line
1	1
1	2
1	3

## PROCESS DOESN'T END FOR ls-line-len
## EXAMPLE: 
## $ls-line-len
## |12      abc-test.txt1h=
# ls-line-len

## ERROR-GENERATED : check-class-dist
## $ cat abc-test.txt | check-class-dist
## | bash: perl-: command not found
## |Can't open : No such file or directory at /home/aveey/bin/count_it.perl line 171.

# cat abc-test.txt | 2bib
